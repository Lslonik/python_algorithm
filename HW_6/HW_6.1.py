# Для оценки «Отлично» необходимо выполнить все требования, указанные в задании и примечаниях.
#
# Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых трех уроков.
# Проанализировать результат и определить программы с наиболее эффективным использованием памяти.
# Примечание: По аналогии с эмпирической оценкой алгоритмов идеальным решением будет:
#
# ● выбрать хорошую задачу, которую имеет смысл оценивать по памяти;
#
# ● написать 3 варианта кода (один у вас уже есть);
#
# ● проанализировать 3 варианта и выбрать оптимальный;
#
# ● результаты анализа (количество занятой памяти в вашей среде разработки) вставить в виде комментариев в файл с кодом.
# Не забудьте указать версию и разрядность вашей ОС и интерпретатора Python;
#
# ● написать общий вывод: какой из трёх вариантов лучше и почему.
#
# Надеемся, что вы не испортили программы, добавив в них множество sys.getsizeof после каждой переменной,
# а проявили творчество, фантазию и создали универсальный код для замера памяти.
# Во втором массиве сохранить индексы четных элементов первого массива. Например,
# если дан массив со значениями 8, 3, 15, 6, 4, 2, второй массив надо заполнить значениями 0, 3, 4, 5,
# (индексация начинается с нуля), т.к. именно в этих позициях первого массива стоят четные числа.
import random
import sys

SIZE = 10000  # int(input('Введите размер массива: '))
MIN_ITEM = 0
MAX_ITEM = 100
array = [random.randint(MIN_ITEM, MAX_ITEM) for _ in range(SIZE)]


def ver_1(arr):
    print(f'Вариант №1.Сгенерированный массив: {arr}.\nМассив с индексами четных элементов сгенерированного элемента'
          f' {[arr_index for arr_index, arr_el in enumerate(arr) if arr_el % 2 == 0]}')
    return locals()


def ver_2(arr):
    array_even = []
    for index, el in enumerate(arr):
        if el % 2 == 0:
            array_even.append(index)

    print(f'Вариант №2.Сгенерированный массив: {arr}.\nМассив с индексами четных элементов сгенерированного элемента'
          f' {array_even}')
    return locals()


def ver_3(arr):
    dict_even = {}
    i = 0
    for index, el in enumerate(arr):
        if el % 2 == 0:
            dict_even.update({i: index})
        i += 1
    print(f'Вариант №3.Сгенерированный массив: {arr}.\nМассив с индексами четных элементов сгенерированного элемента'
          f' {list(dict_even.values())}')
    return locals()


def show(x, size_of_el=0):
    size_of_el += sys.getsizeof(x)
    if hasattr(x, '__iter__'):
        if hasattr(x, 'items'):
            for key, value in x.items():
                size_of_el += sys.getsizeof(key)
                size_of_el += sys.getsizeof(value)
        else:
            for el in x:
                size_of_el += sys.getsizeof(el)
    return size_of_el


def parsing_a_dictionary(my_dict):
    sum_of_size = 0
    for el in my_dict.values():
        sum_of_size += show(el)
    return f'всего заняло памяти: {sum_of_size} байт'


print(parsing_a_dictionary(ver_1(array)))
print(parsing_a_dictionary(ver_2(array)))
print(parsing_a_dictionary(ver_3(array)))

# Вывод:
# Ubuntu 20.04.1 LTS 64-бит
# Python 3.8.2 64 бит
# вариант №1 занимает 367260 байт памяти
# вариант №2 занимает 552500 байт памяти
# вариант №3 занимает 799200 байт памяти
# меньше всего занимает места вариант № 1 так как там нет лишних переменных, и лучше всего выбрать
# именно 1й вариант
